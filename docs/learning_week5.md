# Week 5：卡顿基础（IO/锁/布局/GC 分类）+ 树 DFS/BFS（minSdk 26）

> 本周目标：把“卡顿”拆成四类可操作问题：IO、锁、布局、GC；每类至少做出 1 个可控复现实验（布局/GC 可以先做轻量版，为 Week6/Week15 深化铺垫）。  
> 本周交付：卡顿排查清单 + 至少 3 个稳定可复现卡顿实验（含证据链）。

---

## 每日固定配方（90 分钟）

- 15m 算法：树 DFS/BFS 题 1 道（递归三板斧 + 层序）
- 45m 阅读 + 笔记：卡顿本质与排查顺序
- 25m Demo：复现 → trace/Profiler 证据 → 规避 → 再验证
- 5m 输出：卡片 1 张

---

## Day 1：卡顿本质与排查顺序

- 算法：二叉树前/中/后序任意 1 题（写清递归返回值/边界/合并）。
- 阅读笔记：写《卡顿排查顺序》
  - 先看主线程是否有长时间 slice
  - 再按类别归因（IO/锁/布局/GC）
- Demo：在 `JankLab` 增加“记录一次验证结论”的固定输出格式（2 行）。
- 输出卡片：《卡顿=主线程 >16.6ms》一句话。

验收：你能说清“为什么 16.6ms”以及“我先看什么证据”。

---

## Day 2：IO 卡顿强化（复现/规避/验证）

- 算法：层序遍历 1 题。
- 阅读笔记：写《主线程 IO 的典型来源》（文件/DB/SP/大日志）。
- Demo：完善 `IoJankLab`
  - 复现：主线程执行一段可控文件读写
  - 修复：后台执行 + 主线程只做 UI
  - 验证：trace/Profiler 证明主线程占用下降
- 输出卡片：《IO 卡顿证据怎么写》。

验收：能用工具证明“主线程不再被 IO 占用”。

---

## Day 3：锁等待卡顿强化（复现/规避/验证）

- 算法：路径类题 1 道（根到叶/路径和任选）。
- 阅读笔记：写《锁等待直觉：主线程在等什么》
  - 资源锁、单例初始化锁、UI 与后台共享状态锁
- Demo：完善 `LockJankLab`
  - 复现：主线程获取锁被阻塞（后台持有锁）
  - 修复：避免主线程争抢该锁（减少锁范围/改成消息传递/改成只读快照）
  - 验证：trace 显示主线程阻塞 section 缩短/消失
- 输出卡片：《锁等待：两句话说明根因》。

验收：能说清“锁对象是谁、谁持有、主线程为何需要它”。

---

## Day 4：布局导致卡顿（轻量版，为 Week6 深化）

- 算法：LCA/树深度等 DFS 题 1 道。
- 阅读笔记：写《布局卡顿的 3 个常见来源》
  - 层级深、重复 measure/layout、频繁 requestLayout
- Demo：
  - 新增 `LayoutJankLab`（轻量）
    - 复现：加载一个“层级很深”的 XML（或动态生成大量 View）
    - 修复：简化层级/约束/拆分
    - 验证：用 Layout Inspector 或 trace 观察相关耗时变化（先能看到差异即可）
- 输出卡片：《布局卡顿：我先优化什么》。

验收：能直观对比“复杂布局 vs 简化布局”的耗时差异（哪怕仅日志+观感）。

---

## Day 5：GC/分配导致卡顿（轻量版，为 Week15 深化）

- 算法：树综合 1 题（DFS+BFS 任意组合）。
- 阅读笔记：写《内存抖动→GC→卡顿的直觉链路》
  - 频繁分配短命对象 → GC 更频繁 → 主线程停顿更易发生
- Demo：
  - 新增 `GcJankLab`（轻量）
    - 复现：按钮触发大量短命对象分配（配合 `Trace`）
    - 修复：减少分配/复用/缓存（先做到“峰值变小/次数减少”即可）
    - 验证：Memory Profiler 看 allocation/GC 变化
- 输出卡片：《GC 卡顿：我怎么证明是它》。

验收：能用 Memory Profiler 指出“分配曲线/GC 行为”的变化趋势。

---

## Day 6：周复盘（卡顿清单 + 3 个标准实验）

- 算法：补短板 1 题（你本周最不稳的树题模型）。
- 阅读笔记：输出《卡顿排查清单（1 页）》：先主线程，再分类，再验证。
- Demo：确保至少 3 个实验满足：复现稳定、证据可见、修复可切换、验证有结论。
- 输出卡片：《Week5 我能复现并解释的卡顿类型》。

本周验收：你能在 10 分钟内现场演示 3 类卡顿（主线程阻塞/IO/锁等待）并给出证据链。


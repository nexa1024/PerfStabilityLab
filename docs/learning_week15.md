# Week 15：深挖 GC/分配与卡顿关联 + 算法补短板（minSdk 26）

> 本周目标：把“GC 导致卡顿”的直觉落实为证据：分配模式、GC 频率、暂停对主线程的影响；做一个“频繁分配 vs 减少分配”的对照实验。  
> 本周交付：GC 卡顿证据链 + 一套减少分配的工程手段清单 + 对照实验页。

---

## 每日固定配方（90 分钟）

- 15m 算法：补短板题 1 道
- 45m 阅读 + 笔记：GC 暂停直觉与观测点（不背收集器名）
- 25m Demo：分配→GC→卡顿对照 + Profiler 证据
- 5m 输出：卡片 1 张

---

## Day 1：GC 暂停直觉（理解层）

- 算法：补短板 1 题。
- 阅读笔记：写《为什么 GC 会影响体验》
  - 分配越多、回收越频繁，越可能产生暂停/抖动
- Demo：复用或增强 `GcJankLab` 的说明与记录字段。
- 输出卡片：《GC 不是坏事，但频率/暂停是问题》。

验收：你能解释“为什么不是所有 GC 都会卡、但频繁/长暂停会”。

---

## Day 2：对照实验（频繁分配→GC→卡顿）复现

- 算法：补短板 1 题。
- 阅读笔记：写《我需要观察哪些指标》
  - 分配速率、GC 次数、主线程耗时峰值
- Demo：
  - `GcJankLab`
    - 复现：循环分配大量短命对象（配合 trace section）
    - 验证：用 Memory Profiler 观察 allocation 与 GC 行为；用 trace 观察主线程耗时段
- 输出卡片：《分配抖动的证据怎么写》。

验收：你能给出“复现时分配/GC 更频繁”的证据描述。

---

## Day 3：修复对照（减少分配/复用/缓存）

- 算法：补短板 1 题。
- 阅读笔记：写《减少分配常见手段》
  - 复用对象、避免装箱、避免临时集合、缓存结果、按需生成
- Demo：
  - `GcJankLab`
    - 修复：实现一个减少分配版本（例如复用 buffer/复用对象/减少临时对象）
    - 验证：对比分配曲线与 GC 次数（写 2 行结论）
- 输出卡片：《减少分配：我改了哪里》。

验收：能看到分配峰值/频率下降，并能说明是哪类对象减少了。

---

## Day 4：把 GC 卡顿纳入卡顿排查清单

- 算法：补短板 1 题。
- 阅读笔记：更新《卡顿排查清单》中的 GC 分支：何时怀疑 GC、怎么取证、怎么修。
- Demo：把 `GcJankLab` 的“验证”输出固定成：分配速率变化 + GC 次数变化。
- 输出卡片：《何时怀疑 GC 是主因》。

验收：你能在卡顿案例中判断“这更像 GC 抖动还是 IO/锁/UI”。

---

## Day 5：输出《GC 卡顿：证明与缓解》

- 算法：错题复盘 1 题。
- 阅读笔记：输出 1 页《GC 卡顿：证明与缓解》
  - 证明：分配/GC/主线程耗时三件套
  - 缓解：减少分配、分批、降级、避免峰值叠加
- Demo：跑一遍“复现 vs 修复”并落盘证据。
- 输出卡片：《GC 卡顿证据链模板》。

验收：你能把 GC 卡顿说成“对照实验”，并能写出证据链。

---

## Day 6：周复盘（GC 证据链一份）

- 算法：补短板 1 题。
- 阅读笔记：写《Week15：GC 卡顿复盘稿》。
- Demo：整理实验参数（默认强度/安全开关），确保可重复演示。
- 输出卡片：《Week15 我能证明的 GC 卡顿》。

本周验收：你能演示“分配多→GC 频繁→体验变差”和“减少分配→指标改善”的闭环。


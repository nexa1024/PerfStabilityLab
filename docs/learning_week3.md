# Week 3：启动链路（冷/温/热、首帧直觉）+ 链表（minSdk 26）

> 本周目标：建立“启动慢从哪里来”的直觉与最小证据链；把启动相关的实验页面搭好，为后续 Week4 深化“初始化治理”打基础。  
> 本周交付：启动实验页（可控慢启动模拟 + 延迟/按需对照）+ 一份启动证据链复盘稿。

---

## 每日固定配方（90 分钟）

- 15m 算法：链表模板题 1 道（反转/快慢指针/环/合并）
- 45m 阅读 + 笔记：启动链路与指标（先到“能解释”层面）
- 25m Demo：可控制造启动慢点 + 日志/trace 记录
- 5m 输出：卡片 1 张

---

## Day 1：启动链路概览 + 指标定义

- 算法：反转链表 1 题（递归/迭代二选一，写清指针更新顺序）。
- 阅读笔记：写《从点击到首帧：你至少要能讲清的 5 个点》
  - 冷/温/热启动差异
  - “首帧/可交互”的概念
  - Application/Provider 初始化的风险
- Demo：在 `StartupLab` 页面里增加说明区：本周要验证的“慢点”是什么。
- 输出卡片：《冷/温/热启动一句话区别》。

验收：你能用 60 秒讲清冷/温/热启动的区别与常见优化方向。

---

## Day 2：实验 — Application 慢初始化模拟（可控）

- 算法：快慢指针题 1 道（找中点/判环任选）。
- 阅读笔记：写《为什么初始化越早越危险》
  - 线程安全、顺序依赖、主线程阻塞、隐性启动开销
- Demo：
  - 在 `Application.onCreate` 增加一个“可控耗时”开关（例如读取本地配置决定是否执行耗时初始化）。
  - 用日志记录初始化开始/结束时间（并落盘）。
- 输出卡片：《启动慢点：我如何记录耗时》。

验收：你能稳定制造“启动更慢”的版本，并且有日志证明耗时增加发生在 Application 初始化。

---

## Day 3：实验 — 延迟/按需初始化对照

- 算法：链表有环及入口 1 题（写清数学推导要点）。
- 阅读笔记：写《延迟/按需初始化的常见做法》
  - 延迟到首屏后、延迟到某功能首次进入、后台空闲时做
- Demo：
  - `StartupLab` 提供开关：
    - 复现：进入 App 即做耗时初始化（主线程）
    - 修复：延迟到点击按钮后（或延迟到页面显示后再后台执行）
    - 验证：比较日志（启动阶段耗时变化）+ trace（如果你愿意抓）
- 输出卡片：《延迟/按需：如何写“修复点”》。

验收：能写出“把耗时从启动阶段挪出去”的证据描述（耗时点移动/主线程占用减少）。

---

## Day 4：Provider/Application 初始化时机理解

- 算法：合并两个有序链表 1 题（写清哨兵节点技巧）。
- 阅读笔记：写《ContentProvider 为什么容易影响启动》
  - 初始化更早、隐式触发、依赖链难治理
- Demo：
  - 在 `StartupLab` 增加一段“初始化清单展示”（哪怕是静态列表）：必须/可延迟/按需三类。
  - 把你 Demo 里已有的“耗时初始化”归类到三类之一并写理由。
- 输出卡片：《我如何给初始化分级》。

验收：你能解释“某个初始化该不该在启动做”的判断依据（收益 vs 风险）。

---

## Day 5：输出《启动优化要点》+ 启动证据链草稿

- 算法：链表综合 1 题（反转+合并/快慢指针组合）。
- 阅读笔记：把本周笔记压缩成 1 页《启动优化要点》
  - 目标指标、常见慢点、常见手段、常见风险
- Demo：
  - 给 `StartupLab` 的“验证”按钮增加：输出本次验证结论（2–3 行）。
- 输出卡片：《启动证据链模板（启动版）》。

验收：`StartupLab` 能在不抓工具的情况下，靠日志给出可解释的证据（以后抓 Perfetto 是加分项）。

---

## Day 6：周复盘（启动证据链一份）

- 算法：补一题你本周最弱链表模型。
- 阅读笔记：写一份《启动证据链复盘稿》
  - 现象→证据（日志/trace）→ 根因假设→ 修复方案→ 回归验证
- Demo：把 `StartupLab` 的复现/修复/验证三按钮都跑通一次并落盘记录。
- 输出卡片：《Week3 我能讲清的启动问题》。

本周验收：你能用 Demo 在 10 分钟内演示“启动阶段做了某个耗时初始化”和“把它延迟/按需后启动阶段更轻”的对照闭环。


# Week 7：内存与泄漏（LeakCanary/引用链）+ 堆/TopK（minSdk 26）

> 本周目标：把“泄漏”从概念变成工具化能力：能复现、能看引用链、能解释根因、能验证修复。  
> 本周交付：至少 2 个泄漏复现实验 + 工具判读笔记（引用链怎么看）+ 泄漏排查清单。

---

## 每日固定配方（90 分钟）

- 15m 算法：堆/TopK 或哈希巩固 1 题（理解为主）
- 45m 阅读 + 笔记：泄漏根因与引用链判读
- 25m Demo：复现泄漏 → 工具证据 → 修复 → 再验证
- 5m 输出：卡片 1 张

---

## Day 1：泄漏 vs 抖动 vs OOM

- 算法：TopK 题 1 道（堆思路/复杂度说清楚即可）。
- 阅读笔记：写《三者区别与指标》
  - 泄漏：对象应该释放但一直被引用
  - 抖动：频繁分配/回收导致 GC 频繁
  - OOM：峰值超过上限
- Demo：`LeakLab` 增加说明：本周要做“可复现泄漏 + 可验证修复”。
- 输出卡片：《泄漏一句话定义》。

验收：你能用 60 秒讲清三者区别。

---

## Day 2：泄漏实验 1 — 静态引用持有 Activity/Context

- 算法：堆题/合并K路（理解）任选 1 道。
- 阅读笔记：写《静态引用泄漏根因》
  - static 单例/缓存/全局集合持有页面对象或 Context
- Demo：
  - `LeakLab`
    - 复现：把 Activity/Fragment 的引用放进 `object` 单例里（或全局 list）
    - 修复：改成 `applicationContext`、弱引用、或在 `onDestroy` 清理（优先清理）
    - 验证：引入 LeakCanary（如果你愿意）或用“弱引用 + 手动触发 GC + 多次进入退出统计”（占位法）
- 输出卡片：《静态引用泄漏：修复点清单》。

验收：能稳定复现“退出页面仍被持有”的证据，并能解释是谁在持有它。

---

## Day 3：泄漏实验 2 — 监听/回调未注销

- 算法：TopK/堆巩固 1 道。
- 阅读笔记：写《回调泄漏根因》
  - Listener、Rx/Flow 收集、Handler/Timer、注册但不注销
- Demo：
  - `LeakLab`
    - 复现：注册一个全局监听（或定时任务）持有 Fragment 引用，不在 `onDestroyView/onDestroy` 注销
    - 修复：在正确生命周期注销/取消 job
    - 验证：LeakCanary/引用链证据（或占位法）
- 输出卡片：《生命周期注销点：我放在哪》。

验收：能写清“正确注销点为什么是这里”，并能验证修复有效。

---

## Day 4：引用链判读与“真泄漏/误报”区分

- 算法：错题复盘 1 题。
- 阅读笔记：写《引用链判读最小方法》
  - 找 GC Root → 找到持有链 → 判断持有是否合理（缓存/单例/线程/静态）
- Demo：
  - 给 `LeakLab` 的“验证”按钮增加：输出“引用链关键节点”的文本（哪怕先手写说明，后面再用工具截图替换）。
- 输出卡片：《引用链：我先看谁》。

验收：你能解释“泄漏链路上的关键持有者是谁”。

---

## Day 5：泄漏排查清单固化

- 算法：TopK/堆综合 1 题。
- 阅读笔记：输出《泄漏排查清单（1 页）》
  - 静态引用、监听未注销、长生命周期 scope、Handler/线程、WebView/Drawable 等
- Demo：把 2 个泄漏实验的“复现步骤/修复点/验证方式”写成页面内可读的说明（日志区也行）。
- 输出卡片：《泄漏闭环：复现→证据→修复→回归》。

验收：你能把两种泄漏都写成标准闭环记录。

---

## Day 6：周复盘（沉淀 2–3 个泄漏模板）

- 算法：补短板 1 题。
- 阅读笔记：整理《Week7 泄漏模板库》：至少 2 条（静态持有、监听未注销）。
- Demo：确保 2 个泄漏实验可重复复现并可验证修复。
- 输出卡片：《Week7 我能定位的泄漏类型》。

本周验收：你能用 Demo 演示“泄漏发生→工具/证据确认→修复→验证通过”的完整过程。


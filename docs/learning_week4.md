# Week 4：初始化治理（依赖/线程安全/顺序）+ 栈队列（minSdk 26）

> 本周目标：把“初始化问题”从概念推进到工程化：能说清依赖关系、并发风险、顺序治理；并在 Demo 里复现一个典型竞态/可见性问题。  
> 本周交付：初始化分级清单 + 初始化调度/按需触发雏形 + 一个竞态问题复现/规避实验。

---

## 每日固定配方（90 分钟）

- 15m 算法：栈/队列模板题 1 道（括号/单调栈/最小栈/队列实现栈）
- 45m 阅读 + 笔记：初始化治理方法（别背术语，背“怎么做”）
- 25m Demo：复现一个初始化竞态/顺序问题并记录证据
- 5m 输出：卡片 1 张

---

## Day 1：为什么“越早初始化越好”是错的

- 算法：有效括号/括号匹配 1 题。
- 阅读笔记：写《早初始化的 4 个代价》
  - 主线程阻塞、顺序依赖、线程安全、后续难回收/难观测
- Demo：在 `StartupLab` 加一个“初始化分级展示”区域（必须/可延迟/按需）。
- 输出卡片：《初始化三分法》。

验收：你能把 Demo 里的初始化点明确归类，并写下理由。

---

## Day 2：实验 — 后台 init + 主线程提前使用（竞态/可见性）

- 算法：最小栈/单调栈 1 题。
- 阅读笔记：写《竞态问题的典型表现》
  - 偶现、难复现、看起来“代码没问题”
- Demo：
  - 新增 `InitRaceLab`
    - 复现：后台线程初始化一个“配置对象”，主线程立刻读取（偶发读到空/默认值）
    - 修复：用明确的同步手段（例如 `CountDownLatch`/`AtomicReference`/单线程串行）保证可见性与顺序
    - 验证：通过日志统计复现次数下降（比如循环 100 次）
- 输出卡片：《竞态：复现→修复→验证怎么写》。

验收：能稳定复现“偶现错误”，并能用修复方案显著降低复现概率（最好变成 0）。

---

## Day 3：初始化调度（按需触发）雏形

- 算法：单调栈经典题 1 道。
- 阅读笔记：写《按需初始化的边界》
  - 首次触发延迟如何接受、失败如何兜底、线程模型如何选
- Demo：
  - 增加一个轻量的 `InitManager`（只要能按 key 触发一次初始化即可）
  - `StartupLab` 的“修复”里把某初始化点改成“点击按钮才初始化”
  - 记录初始化开始/结束时间并落盘
- 输出卡片：《按需初始化：我如何证明它没影响首屏》。

验收：你能证明“启动阶段减少了某段工作”，并且“功能首次进入时才付出成本”。

---

## Day 4：线程安全与顺序依赖清单化

- 算法：队列/栈互相实现 1 题。
- 阅读笔记：写《初始化依赖怎么梳理》
  - 列出依赖：A 依赖 B 还是反过来？是否能延迟？
  - 并发点：多线程可能同时触发吗？
- Demo：
  - 在 `StartupLab` 增加一个“依赖顺序展示”文本（哪怕是静态图/列表）。
  - 把你现有 2–3 个初始化点写出依赖关系（并落盘为文档记录）。
- 输出卡片：《初始化依赖三问》：依赖谁？谁触发？在哪里触发？

验收：你能用清单方式回答“为什么这个初始化要放这里”。

---

## Day 5：本周整理与对照验证

- 算法：栈队列综合 1 题（单调栈/最小栈任选）。
- 阅读笔记：输出《初始化治理一页纸》
  - 分类、顺序、并发风险、按需策略、回归验证方式
- Demo：
  - `InitRaceLab` 跑一轮复现/修复/验证并写 2 行结论到日志区。
  - `StartupLab` 跑一轮“启动做 vs 按需做”的对照并写结论。
- 输出卡片：《初始化治理：我能复用的规则》。

验收：你能把“竞态实验”和“按需实验”都写成标准证据链记录。

---

## Day 6：周复盘（固化为工程习惯）

- 算法：补短板 1 题（你本周最不稳的栈队列模型）。
- 阅读笔记：把 Week3-4 合并输出《启动与初始化治理：排查路径图》（1 页）。
- Demo：把 `InitManager/InitRaceLab` 的代码与记录整理到清晰目录，便于后续复用。
- 输出卡片：《Week4 我能复现并修复的初始化问题》。

本周验收：你能演示一次“初始化竞态导致偶现 bug”并给出修复与验证；并能解释“为什么要按需/延迟”。


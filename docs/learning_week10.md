# Week 10：Crash 治理（日志/混淆/回滚思路）+ DP 进阶（minSdk 26）

> 本周目标：把 Crash 从“看栈修 bug”升级为“治理闭环”：发现→定位→修复→监控→回滚/灰度；Demo 里做可控 crash 与“崩溃前上下文记录”。  
> 本周交付：Crash 闭环清单 + 3 类可控 crash 实验 + 上下文记录能力。

---

## 每日固定配方（90 分钟）

- 15m 算法：DP 进阶题 1 道（强调推导与边界）
- 45m 阅读 + 笔记：Crash 定位与治理闭环
- 25m Demo：可控 crash + 上下文记录 + 验证
- 5m 输出：卡片 1 张

---

## Day 1：Crash 定位基本流程

- 算法：DP 题 1 道（写清状态/转移/初始化）。
- 阅读笔记：写《Crash 定位五步》
  - 版本/机型/场景 → 栈顶 → 还原输入 → 复现 → 修复与回归
- Demo：`CrashLab` 增加说明区与三按钮占位逻辑。
- 输出卡片：《Crash 证据=栈+版本+场景》。

验收：你能用 60 秒讲清 crash 定位五步。

---

## Day 2：可控 Crash 实验（NPE/越界/非法状态）

- 算法：DP 题 1 道。
- 阅读笔记：写《三类常见 crash》
  - NPE、IndexOutOfBounds、IllegalState（状态机错误）
- Demo：
  - `CrashLab`
    - 复现：提供 3 个按钮或 1 个按钮+下拉选择，触发三类 crash（可控）
    - 修复：加校验/兜底/状态保护（先做到“不崩”）
    - 验证：点击验证后不再 crash，并写 2 行结论到日志区
- 输出卡片：《防御性校验的边界》。

验收：你能稳定复现与修复，并清楚写出“修复点是什么”。

---

## Day 3：崩溃前上下文记录（最小可用）

- 算法：DP 题 1 道（写清遍历顺序）。
- 阅读笔记：写《崩溃前记录什么最有价值》
  - 页面名、用户操作、线程名、关键参数（避免敏感信息）
- Demo：
  - 实现一个简单的 `CrashContext`：
    - 每次点击实验按钮都记录“最后一次操作/页面/时间”
    - 在全局异常处理（或 `CrashLab` 内捕获后手动记录）把上下文写入 `filesDir`（用于复盘）
- 输出卡片：《崩溃前上下文最小字段》。

验收：你能在崩溃后找到一份本地记录，看到“崩溃前最后一次操作”。

---

## Day 4：混淆与 mapping 的意义（理解层面）

- 算法：DP 综合 1 题。
- 阅读笔记：写《为什么线上栈看不懂》
  - 混淆导致类名方法名变化；mapping 用于还原
- Demo：在 `CrashLab` 的“验证”按钮里输出：若开启混淆，定位需要哪些产物（mapping、版本号等）。
- 输出卡片：《mapping 的作用一句话》。

验收：你能解释“为什么需要 mapping 以及它如何参与定位”。

---

## Day 5：输出《Crash 闭环清单》

- 算法：错题复盘 1 题。
- 阅读笔记：输出《Crash 治理闭环》（1 页）：发现→定位→修复→监控→灰度/回滚→复盘预防。
- Demo：让 `CrashLab` 的复现/修复/验证三按钮可在“同一次会话”里完成闭环（避免频繁重启造成干扰）。
- 输出卡片：《Crash 证据链模板》。

验收：你能把 crash 问题写成标准闭环记录，而不是“修了就完”。

---

## Day 6：周复盘（Crash 证据链一份）

- 算法：补短板 1 题（DP 最不稳的模型）。
- 阅读笔记：写《Week10：Crash 证据链复盘稿》。
- Demo：整理 crash 实验的“安全提示”（避免影响日常开发）。
- 输出卡片：《Week10 我能治理的 crash 类型》。

本周验收：你能现场演示“可控 crash→记录上下文→修复→验证”，并用闭环语言描述全过程。

